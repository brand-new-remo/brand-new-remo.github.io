import{_ as e,c as o,o as d,a as c}from"./app-D3FtvwAO.js";const i={},l=c('<h1 id="vue3在diff阶段都优化了哪些" tabindex="-1"><a class="header-anchor" href="#vue3在diff阶段都优化了哪些"><span><strong>Vue3在diff阶段都优化了哪些</strong></span></a></h1><p><code>Vue3</code>的diff算法优化点如下：</p><ul><li><code>静态提升</code>：在<code>模板编译时</code>，会将没有用到<code>动态变量</code>的<code>节点或属性(class、style这些元素属性)</code>进行<code>静态提升</code>，在进行render时，直接复用旧节点。而在<code>Vue2中</code>，无论元素是否使用了<code>动态变量</code>，每次更新都会<code>重新创建</code>，这也是为什么<code>Vue3</code>最好使用<code>template</code>而不是render函数，因为模板编译时会帮我们做优化；</li><li><code>预字符串化</code>：当编译器遇到<code>大量的静态节点时</code>，会将这一整部分变成字符串，<code>减少VNode的创建</code>，渲染为<code>静态节点</code>，而在Vue2中，则会将这些节点一个个变成虚拟节点；</li><li><code>缓存事件处理函数</code>：在Vue3中，会将dom元素绑定的事件进行<code>缓存</code>，在进行patch的时候会使用缓存中的事件处理函数；</li><li><code>Block Tree</code>：在Vue3中，<code>Block</code>用于提取那些<code>动态属性</code>的节点，从而在进行更新时，可以精准的比较<code>Block中的内容</code>，只更新那些使用动态节点的节点；</li><li><code>patchFlags</code>：<code>patchFlags</code>是编译器生成的<code>优化提示</code>，它标记了节点的哪些属性是<code>动态的</code>，从而在进行更新时，精确的对某些属性进行更新；</li><li><code>shapeFlags</code>：<code>shapeFlags</code>也是一个标识，它标识了当前虚拟节点的类型，从而可以在进行diff时能够省去<code>类型判断</code>，对不同类型做不同的更新处理。</li></ul><p>Vue 3 在 diff 阶段进行了一系列的优化，主要集中在以下几个方面：</p><ol><li><strong>静态节点提升</strong>： 在 Vue 3 中，编译器会对模板进行静态节点提升优化，将静态节点（不包含动态数据的节点）提取出来作为单独的常量，减少 diff 过程中对静态节点的比较，从而提高渲染性能。</li><li><strong>事件侦听器缓存</strong>： Vue 3 使用了事件侦听器的缓存机制，可以将事件处理函数进行缓存，减少每次渲染时重新创建事件处理函数，提高了事件处理的效率。</li><li><strong>静态树提升</strong>： 类似静态节点提升，Vue 3 还对静态树（静态节点的嵌套结构）进行了优化。静态树提升可以将静态节点的嵌套结构提取出来作为单独的常量，减少 diff 过程中对静态树的比较，进一步提高了渲染性能。</li><li><strong>快速路径和节点缓存</strong>： Vue 3 在 diff 过程中使用了快速路径（fast path）和节点缓存机制，可以快速跳过不必要的比较和操作，提高了 diff 的效率。这些优化可以减少不必要的 DOM 操作，从而减少页面的重绘和重排，提高了整体的渲染性能。</li><li><strong>优化的算法</strong>： Vue 3 在实现 diff 算法时采用了一些优化的策略和算法，例如深度优先遍历算法、双端比较算法等，以提高 diff 的效率和性能。</li></ol><p>通过以上优化措施，Vue 3 在 diff 阶段可以更加高效地处理组件更新，提高了渲染性能和用户体验。这些优化使得 Vue 3 在处理大型应用和复杂组件时能够保持良好的性能表现。</p>',6),t=[l];function a(s,n){return d(),o("div",null,t)}const r=e(i,[["render",a],["__file","vue3diff.html.vue"]]),u=JSON.parse('{"path":"/vue/vue3diff.html","title":"Vue3在diff阶段都优化了哪些","lang":"zh-CN","frontmatter":{"date":"2024-06-03T00:00:00.000Z","category":["Vue"],"tag":["Vue","Diff"]},"headers":[],"git":{"updatedTime":1717401658000,"contributors":[{"name":"gangqiang duan","email":"duangangqiang@users.noreply.github.com","commits":1}]},"filePathRelative":"vue/vue3diff.md","excerpt":"\\n<p><code>Vue3</code>的diff算法优化点如下：</p>\\n<ul>\\n<li><code>静态提升</code>：在<code>模板编译时</code>，会将没有用到<code>动态变量</code>的<code>节点或属性(class、style这些元素属性)</code>进行<code>静态提升</code>，在进行render时，直接复用旧节点。而在<code>Vue2中</code>，无论元素是否使用了<code>动态变量</code>，每次更新都会<code>重新创建</code>，这也是为什么<code>Vue3</code>最好使用<code>template</code>而不是render函数，因为模板编译时会帮我们做优化；</li>\\n<li><code>预字符串化</code>：当编译器遇到<code>大量的静态节点时</code>，会将这一整部分变成字符串，<code>减少VNode的创建</code>，渲染为<code>静态节点</code>，而在Vue2中，则会将这些节点一个个变成虚拟节点；</li>\\n<li><code>缓存事件处理函数</code>：在Vue3中，会将dom元素绑定的事件进行<code>缓存</code>，在进行patch的时候会使用缓存中的事件处理函数；</li>\\n<li><code>Block Tree</code>：在Vue3中，<code>Block</code>用于提取那些<code>动态属性</code>的节点，从而在进行更新时，可以精准的比较<code>Block中的内容</code>，只更新那些使用动态节点的节点；</li>\\n<li><code>patchFlags</code>：<code>patchFlags</code>是编译器生成的<code>优化提示</code>，它标记了节点的哪些属性是<code>动态的</code>，从而在进行更新时，精确的对某些属性进行更新；</li>\\n<li><code>shapeFlags</code>：<code>shapeFlags</code>也是一个标识，它标识了当前虚拟节点的类型，从而可以在进行diff时能够省去<code>类型判断</code>，对不同类型做不同的更新处理。</li>\\n</ul>"}');export{r as comp,u as data};
